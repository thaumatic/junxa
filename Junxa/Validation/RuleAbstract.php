<?php

namespace Thaumatic\Junxa\Validation;

use Thaumatic\IndefiniteArticle;
use Thaumatic\Junxa\Column;
use Thaumatic\Junxa\Exception\JunxaInvalidArgumentException;
use Thaumatic\Junxa\Exception\JunxaConfigurationException;

/**
 * Base class for Junxa validation rules.
 */
abstract class RuleAbstract
{

    /**
     * @const string the default failure message format to use if none is given
     */
    const DEFAULT_FAILURE_MESSAGE_FORMAT = 'The %%NAME%% specified is not valid.';

    /**
     * @var array the parameters provided for the rule instance
     */
    private $parameters;

    /**
     * @var Thaumatic\Junxa\Column the column model a failure message is
     * being generated for by {@see getFailureMessage()}
     */
    private $failureMessageColumn;

    /**
     * @var bool whether the failure message being generated by
     * {@see getFailureMessage()} should prepend table names to column
     * names
     */
    private $failureMessageIncludeTableName;

    /**
     * @param ...mixed parameters as appropriate to the rule class
     * @throws Thaumatic\Junxa\Exception\JunxaInvalidArgumentException if the
     * number of parameters does not match {@see getParameterCount()}
     */
    public function __construct(...$parameters)
    {
        if (count($parameters) !== $this->getParameterCount()) {
            throw new JunxaInvalidArgumentException(
                'expected parameter count '
                . $this->getParameterCount()
                . ', got '
                . count($parameters)
            );
        }
        $this->parameters = $parameters;
    }

    /**
     * Should be overridden by inheritor classes as appropriate.
     *
     * @return string the abstract format of the failure message to use for
     * the rule class
     */
    public function getFailureMessageFormat()
    {
        return self::DEFAULT_FAILURE_MESSAGE_FORMAT;
    }

    /**
     * Should be overridden by inheritor classes as appropriate.
     *
     * @return int the number of parameters appropriate to the rule class
     */
    public function getParameterCount()
    {
        return 0;
    }

    /**
     * Should be overridden by inheritor classes as appropriate.
     *
     * @return bool whether the rule should be checked when a form element
     * corresponding to a column it is attached to is changed
     */
    public function getCheckOnChange()
    {
        return false;
    }

    /**
     * Performs validation of a given field value against this rule.  Besides
     * returning true or false according to whether the value is valid, this
     * function may mutate the value (this being considered a "coerce into
     * validity" case of the concept of validation).
     *
     * @param Thaumatic\Junxa\Column the column with respect to which the rule
     * is being evaluated
     * @param mixed the value being provided for the field
     * @param array<string:mixed> all data values being provided for fields in the
     * current event
     * @param string any prefix being applied to field names for lookup in the
     * data array within this validation's immediate context
     * @param string any suffix being applied to field names for lookup in the
     * data array within this validation's immediate context
     * @return bool whether the value is valid for the column
     */
    abstract public function validate(Column $column, &$value, $data, $prefix, $suffix);

    /**
     * This function is expected to be overridden by inheritor classes and
     * to return an array of JavaScript snippets, each of which is a
     * conditional statement which, if false, will cause validation against
     * the rule to fail.
     *
     * @param Thaumatic\Junxa\Column the column with respect to which the rule
     * is being evaluated
     * @param string a JavaScript identifier that can be used to refer to the
     * DOM element defining a value for the field
     * @param array<string:mixed> for passing arbitrary processing options
     * @return array<string> JavaScript condition snippets
     */
    public function getJavascriptFailureConditions(Column $column, $refer, $options = [])
    {
        return [];
    }

    /**
     * This function is expected to be overridden by inheritor classes and
     * to return an array of lines of JavaScript code which will be executed
     * when validation of the rule is being performed; generally this is
     * expected to be code that mutates the value of the field (this being
     * considered a "coerce into validity" case of the concept of validation).
     *
     * @param Thaumatic\Junxa\Column the column with respect to which the rule
     * is being evaluated
     * @param string a JavaScript identifier that can be used to refer to the
     * DOM element defining a value for the field
     * @param array<string:mixed> for passing arbitrary processing options
     * @return array<string> lines of JavaScript code
     */
    public function getJavascriptProcessing(Column $column, $refer, $options = [])
    {
        return [];
    }

    /**
     * @param Thaumatic\Junxa\Column the column for which to generate a
     * failure message
     * @param bool whether the names of columns should have their table
     * names prepended
     * @return string the failure message to use for a failure of this rule
     * class in the context specified
     */
    final public function getFailureMessage(Column $column, $includeTableName = false)
    {
        $this->failureMessageColumn = $column;
        $this->failureMessageIncludeTableName = $includeTableName;
        $out = preg_replace_callback(
            '/%%([^%]+)%%/',
            [$this, 'processFailureMessageReplacement'],
            $this->getFailureMessageFormat()
        );
        $this->failureMessageColumn = null;
        $this->failureMessageIncludeTableName = null;
        return $out;
    }

    /**
     * Determines the output to use in a failure message for a replacement code
     * found by getFailureMessage() using preg_replace_callback().
     *
     * @param array<string> a match array from preg_replace_callback()
     * @return string the text to replace the code with
     * @throws Thaumatic\Junxa\Exception\JunxaConfigurationException if the
     * replacement code is not supported
     */
    private function processFailureMessageReplacement(array $match)
    {
        $column = $this->failureMessageColumn;
        $db = $column->getDatabase();
        $addArticle = false;
        $fromColumn = false;
        switch ($match[1]) {
            case 'NAME_WITH_ARTICLE':
                $addArticle = true;
                // fallthrough
            case 'NAME':
                $out = $column->getName();
                $fromColumn = true;
                break;
            case 'NAME_PLURAL':
                $out = $db->getPluralFromSingular($out);
                $fromColumn = true;
                break;
            default:
                if (preg_match('/^PARAM_(\d+)(_WITH_ARTICLE)?$/', $match[1], $paramMatch)) {
                    $paramNum = intval($paramMatch[1]);
                    if ($paramNum <= 0) {
                        throw new JunxaConfigurationException('parameter number ' . $paramNum . ' is not valid');
                    }
                    if ($paramNum > $this->getParameterCount()) {
                        throw new JunxaConfigurationException(
                            'rule has parameter count '
                            . $this->getParameterCount()
                            . ', parameter '
                            . $paramNum
                            . ' requested'
                        );
                    }
                    $out = $this->parameters[$paramNum];
                    if (!empty($paramMatch[2])) {
                        $addArticle = true;
                    }
                    break;
                }
                throw new JunxaConfigurationException('unsupported replacement code %%' . $match[1] . '%%');
        }
        if ($fromColumn && $this->failureMessageIncludeTableName) {
            $tableName = $column->getTable()->getName();
            if ($db->getOption(Junxa::DB_TABLES_ARE_PLURALS)) {
                $tableName = $db->getSingularFromPlural($tableName);
            }
            $out = $tableName . ' ' . $out;
        }
        if ($addArticle) {
            $out = IndefiniteArticle::A($out);
        }
        return $out;
    }

}
